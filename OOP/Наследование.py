class Phone:

    def __init__(self, n, p):
        self.number = n
        self.price = p

    def set(self):
        print("что то ")


class Phone2(Phone):
    #def __init__(self):      # Указали что хотим сделать инициализацию от класа Phone, в подкласе Phone2
        #Phone.__init__(self) # Так как поддерживается множестенное наследование, нужно прописывать каддому, не практично, нужно super
                              # Если клаасы от которых я наследуюсь имеют общего предка, какойто клас ыполнит сой конструктор 2 раза

    def __init__(self, n , p):                             # Что бы использовать конструктор в класе наследнике его необходимо вызвать, с помощью super
        super(Phone2, self).__init__(n, p)   # Функция супер принимает два пргумента, первый это класс для которого вызываем, второй self
                                                    # для какого обьекта ето все происходит, далее init, функция super сама проедется по всем класам,
                                                    # и вызовет конструктор если это нужно
    def send_mail(self):
        pass

    def set(self):
        super(Phone2, self).set()  # В данном случае мы перегрузили метод, но хотим испотльзоать не перегруженый с класа родителя
        print("room")

obj0 = Phone(1, 2)
obj1 = Phone2(2, 3)
print(obj0.number)
print(obj1.set())